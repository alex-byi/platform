MODULE Icon;

REQUIRE Utils, Reflection;

// Icon properties

type(STRING styles) = IF styles = 'bi' THEN 'bi' ELSE ('fa' IF styles IS STRING); 

CLASS Icon;
name '{icon.name}' = DATA STRING (Icon);
explicit = DATA STRING (Icon);
label '{icon.label}' = DATA STRING (Icon);
terms '{icon.terms}' = DATA STRING (Icon);
synonyms '{icon.synonyms}' = DATA STRING (Icon);
styles '{icon.free.class}' = DATA STRING (Icon);

type(Icon i) = type(styles(i)) MATERIALIZED;
INDEX name(Icon i), type(i);
icon = GROUP AGGR Icon icn BY name(icn), type(icn) MATERIALIZED INDEXED;

searchStyles(Icon i) = IF type(i) = 'bi' THEN 'lsfreg'
                              ELSE IF styles(i) = 'brands' THEN '' 
                              ELSE 'lsfsol' + (IF styles(i) LIKE '%regular%' THEN ' lsfreg' ELSE ('' IF i IS Icon)) MATERIALIZED;  
iconClass(STRING s, Icon i) = IF type(i) = 'bi' THEN 'bi bi-' + name(i)
                              ELSE ((IF styles(i) = 'brands' THEN 'fa-brands'
                              ELSE (IF endsWith(s, 'Lsfreg') AND styles(i) LIKE '%regular%' THEN 'fa-regular' ELSE 'fa')) + ' fa-' + name(i)); // should correspond AppServerImage.createDefaultImage -> getBestIcon param
vector '{icon.vector}' (Icon i) = tsVector(explicit(i), label(i), terms(i), CONCAT ' ', synonyms(i), searchStyles(i)) MATERIALIZED INDEXED MATCH;
nameToIconQuery(STRING s) = splitCamelCase(s, ' | ');

// Searching the best icon

bestIconNames = DATA LOCAL BOOLEAN (STRING); // input
bestIconClasses = DATA LOCAL STRING (STRING); // output
bestIconRanks = DATA LOCAL DOUBLE (STRING); // output
getBestIcons() {
    // materializing tsqueries since postgres won't do that
    LOCAL bestIconMatchQueries = TSQUERY (STRING);
    LOCAL bestIconRankQueries = TSQUERY (STRING);
    bestIconMatchQueries(STRING s) <- toTsQuery(nameToIconQuery(left(s, length(s) - 6))) WHERE bestIconNames(s);  // should correspond AppServerImage.createDefaultImage -> getBestIcon param
    bestIconRankQueries(STRING s) <- toTsQuery(nameToIconQuery(s)) WHERE bestIconNames(s);
    
    FOR TSQUERY mq = bestIconMatchQueries(STRING s) AND TSQUERY rq = bestIconRankQueries(s) AND Icon lastIcon = (GROUP LAST Icon icn IF vector(icn) MATCH mq ORDER tsRank(vector(icn), rq)) DO {
        bestIconClasses(s) <- iconClass(s, lastIcon);
        bestIconRanks(s) <- tsRank(vector(lastIcon), rq);
    }
}

// Icon import

term = DATA LOCAL STRING(INTEGER);
termIcon = DATA LOCAL INTEGER (INTEGER);
synonym = DATA LOCAL STRING(INTEGER);
synonymIcon = DATA LOCAL INTEGER (INTEGER);
style = DATA LOCAL STRING(INTEGER);
styleIcon = DATA LOCAL INTEGER (INTEGER);

label = DATA LOCAL STRING(INTEGER);
name = DATA LOCAL STRING(INTEGER);

FORM importIcons
    OBJECTS value = INTEGER 

    PROPERTIES(value) label, name

    OBJECTS terms=INTEGER
    PROPERTIES(terms) term EXTID 'value'
    FILTERS termIcon(terms) = value

    OBJECTS synonyms=INTEGER
    PROPERTIES (synonyms) synonym EXTID 'value'
    FILTERS synonymIcon(synonyms) = value

    OBJECTS free=INTEGER
    PROPERTIES (free) style EXTID 'value'
    FILTERS styleIcon(free) = value
;

terms = GROUP CONCAT term(INTEGER i), ' ' ORDER i BY termIcon(i);
synonyms = GROUP CONCAT synonym(INTEGER i) , ' ' ORDER i BY synonymIcon(i);
styles = GROUP CONCAT style(INTEGER i), ' ' ORDER i BY styleIcon(i);
type (INTEGER i) = type(styles(i));

importIcons '{icon.import.json}' () {
    
    APPLY {
        readResource('/web/icons_with_synonyms.json');

        IMPORT importIcons JSON FROM resource();

        FOR name(INTEGER i) AND NOT icon(name(i), type(i)) INLINE NEW icn = Icon DO {
            name(icn) <- name(i);
            styles(icn) <- styles(i); // need this to fill the type
        }

        FOR name(Icon icn) = name(INTEGER i) AND type(icn) = type(i) INLINE DO {
            label(icn) <- lower(label(i));
            terms(icn) <- lower(terms(i));
            synonyms(icn) <- lower(synonyms(i));
            styles(icn) <- styles(i);
        }

        DELETE Icon icn WHERE icn IS Icon AND NOT [GROUP SUM 1 BY name(INTEGER i), type(i)](name(icn), type(icn));
    }

    // updating properties
    LOCAL allProperties = STRING (STRING);
    readResourcePaths('/[^/]*Icons\\.properties');
    FOR resourcePaths(STRING path) DO {
        readResource(path);
        
        readProperties(RAWFILE(resource()));
        
        allProperties(STRING s) <- properties(s) WHERE properties(s);        
    }

    explicit(Icon icn) <- [GROUP CONCAT splitCamelCase(STRING s AS STRING, ' ') , ' ' ORDER s BY allProperties(s)](name(icn));

    APPLY;
}

// Icons form

search '{icon.action.name}' = DATA LOCAL STRING ();
FORM icons '{navigator.icon}' 
    PROPERTIES() importIcons, search ON CHANGE {
        INPUT s = search() CHANGE DO {
            bestIconNames(s) <- TRUE;
            getBestIcons();
        }
    } 
    PROPERTIES bestIconClass '{icon.best.icon.name}' = bestIconClasses(search())  READONLY IMAGE bestIconClasses(search()), bestIconRank '{icon.best.icon.rank}' = bestIconRanks(search()) READONLY 
    OBJECTS i = Icon 
    PROPERTIES iconImage '{icon.icon}' = {} IMAGE iconClass(search(), i) GRID, rank '{icon.rank}' = tsRank(vector(i), nameToIconQuery(search())) 
    PROPERTIES(i) READONLY name, explicit, label, terms, synonyms, styles, vector
    PROPERTIES(i) DELETE
;

DESIGN icons {
    OBJECTS {
        NEW import {
            MOVE PROPERTY(importIcons()) {
                fontSize = 36;
            }
        }
        NEW search {
            MOVE PROPERTY(search()) {
                fontSize = 36;
                width = 500;
            }
        }
        NEW bestIcon {
            MOVE PROPERTY(bestIconClass) {
                fontSize = 36;
                width = 500;
            }
            MOVE PROPERTY(bestIconRank) {
                fontSize = 36;
                width = 500;
            }
        }
        NEW icons {
            fill = 1;
            MOVE BOX(i);
        }
    }
}

NAVIGATOR {
    system {
        NEW icons AFTER metadata;
    }
}